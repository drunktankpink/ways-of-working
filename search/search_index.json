{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Ways of Working","text":"<p>Platform Engineering - Best practices, standards, policies &amp; procedures</p>"},{"location":"#about","title":"About","text":"<p>This site is authored with MKDocs For full documentation visit mkdocs.org. Please see below for useful commands</p> <p>In addition, this website makes use of the Material for MkDocs theme.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The MK Docs configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"AWS/aws-naming-convention/","title":"Naming Conventions","text":"<p>The purpose of this document is not for it to be adhered to by the letter, but to act as a guide which can be used to support the process of defining naming conventions as well as highlight the reason why you should set and follow them.</p>"},{"location":"AWS/aws-naming-convention/#placeholders","title":"Placeholders","text":"<p>The following placeholders can be used to define a consistent naming convention.</p> Placeholder Description Example Value Short Value <code>&lt;org_name&gt;</code> Organisation that owns the resources Capgemini  Dunder Mifflin Paper Company  Genco Pura Olive Oil Company cg  dmpc  genco <code>&lt;aws_account&gt;</code> AWS Account containing the resources  As the name of an account must be a single word, I would recommend setting a value that combines <code>&lt;org_name&gt;</code> &amp; <code>&lt;environment&gt;</code>  However this may or may not be suitable depending on the hierarchy and set up of AWS Accounts Capgemini Production Account  Dunder Mifflin Paper Company Network Account  Genco Pura Olive Oil Company Development Account cg-prod  dmpc-network  genco-dev <code>&lt;region&gt;</code> AWS Region used eu-west-1  eu-west-2  us-east-1 euw1  euw2  ue1 <code>&lt;availability_zone&gt;</code> AWS Availability Zone eu-west-2a  eu-west-2b  eu-west-2c  us-east-2a  us-east-2b  us-east-2c euw2a  euw2b  euw2c  ue1a  ue1b  ue1c <code>&lt;aws_resource&gt;</code> AWS Resource abbreviation VPC  Subnet  Route Table  Network ACL  Transfer Gateway  Security Group  EC2 Instance  Auto Scaling Group  ECS Cluster  ECS Task  EKS Cluster  S3 Bucket  KMS Key  KMS Policy  IAM Role  IAM Policy vpc  subnet  rtb  nacl  tgw  sg  ec2  asg  ecs-cluster  ecs-task  eks-cluster  s3  kms  kms-policy  iam-role  iam-policy <code>&lt;environment&gt;</code> The environment being used for the resources Development  Test  Staging  UAT  Production  Shared Services  Sandbox  dev  test  staging  uat  prod  shared  sandbox <code>&lt;business_unit&gt;</code> The business unit of the provisioned resources Cloud Infrastructure Services cis <code>&lt;team&gt;</code> The team owning the provisioned resources Platform Engineering  Warehouse  Sales pe  wh  sales <code>&lt;resource_identifier&gt;</code> Free form used to describe the resource  This could be the name of an application, the function, the client or a combination of all. <code>&lt;client&gt;</code> If applicable, the client for provisioned resources <p>By using placeholders like above, prefixes can be specified for account level/wide resources, such as VPCs, subnets etc.  Prefixes can also be specified for application level resources, which are specific to particular applications/teams/clients, such as EC2 instances, ECS clusters or Lambda functions.</p>"},{"location":"AWS/aws-naming-convention/#naming-prefixes","title":"Naming prefixes","text":"Type Convention Comment Example Account Naming Prefix <code>&lt;org_name&gt;</code>-<code>&lt;environment&gt;</code>-<code>&lt;context&gt;</code> <code>&lt;aws_account&gt;</code>-<code>&lt;context&gt;</code> Account naming prefixes can follow their own structure, or they could begin with the account name, if AWS accounts have a different convention.  <code>&lt;context&gt;</code> can be used if necessary, for example, if there are multiple VPCs within the same AWS account, this can be used to differentiate and describe each. cp-prod  dmpc-network  genco-dev Team Naming Prefix <code>&lt;business_unit&gt;</code>-<code>&lt;team&gt;</code>-<code>&lt;environment&gt;</code>-<code>&lt;context&gt;</code> <code>&lt;context&gt;</code> can be used if necessary, for example this could be used to describe a service or sub division within a team.  <code>&lt;business_unit&gt;</code> could be used in conjunction with <code>&lt;team&gt;</code>, for example <code>cis-pe-prod</code> <code>&lt;org_name&gt;</code> can be appended as a prefix cp-cis-pe-prod  dmpc-wh-staging  genco-sales-dev"},{"location":"AWS/aws-naming-convention/#aws-examples","title":"AWS Examples","text":"<p>Below are examples which can be used for inspiration.  Again, these are suggestions that be adapted for individual use cases. For example, you may chose to omit <code>&lt;region&gt;</code> if you only deploy into a single region.</p>"},{"location":"AWS/aws-naming-convention/#aws-accounts","title":"AWS Accounts","text":"AWS Resource Naming Convention Comment Example AWS Account Name <code>&lt;org_name&gt;</code>-<code>&lt;environment&gt;</code> cg-prod  dmpc-network  genco-dev"},{"location":"AWS/aws-naming-convention/#vpc-resources","title":"VPC Resources","text":"AWS Resource Naming Convention Comment Example VPC <code>{{account_naming_prefix}}-&lt;region&gt;-&lt;aws_resource&gt;</code> cg-prod-ue1-sharedservices-vpc  dmpc-network-euw1-vpc  genco-dev-vpc Subnets <code>{{account_naming_prefix}}-&lt;region&gt;-&lt;availability_zone&gt;-{{subnet_type}}-&lt;aws_resource&gt;</code> <code>{{subnet_type}}</code> should describe the purpose of the subnet. For example, it could be one of: <ul><li>public</li><li>private</li><li>app</li><li>data</li></ul> <code>&lt;availability_zone&gt;</code> can also be used after <code>&lt;aws_resource&gt;</code>. The value of this could be a shortened version of the AWS availability zone, or just the letter for the availability zone. cg-prod-ue1-sharedservices-private-subnet-a  dmpc-network-euw1b-public-subnet  genco-dev-data-subnet-euw2c Route Tables <code>{{account_naming_prefix}}-&lt;region&gt;-{{route_type}}-&lt;aws_resource&gt;</code> <code>{{route_type}}</code> should describe the purpose. It could be one of: <ul><li>public</li><li>private</li></ul> cg-prod-ue1-sharedservices-private-rt  dmpc-network-public-rt  genco-dev-private-rt Network ACL <code>{{account_naming_prefix}}-&lt;region&gt;-{{nacl_type}}-&lt;aws_resource&gt;</code> <code>{{nacl_type}}</code> should describe the NACL. It could be one of <ul><li>public</li><li>private</li></ul> cg-prod-ue1-sharedservices-private-nacl  dmpc-network-euw1-public-nacl  genco-dev-private-nacl Transit Gateway <code>{{account_naming_prefix}}-&lt;region&gt;-&lt;aws_resource&gt;</code> cg-prod-ue1-sharedservices-tgw  dmpc-network-euw1-tgw  genco-dev-tgw Transit Gateway Attachment <code>{{account_naming_prefix}}-&lt;region&gt;-&lt;aws_resource&gt;</code> cg-prod-ue1-sharedservices-tgwa  dmpc-network-euw1-tgw-att  genco-dev-tga NAT Gateway <code>{{account_naming_prefix}}-&lt;region&gt;-&lt;aws_resource&gt;</code> cg-prod-ue1-sharedservices-ngw  dmpc-network-euw1-ngw  genco-dev-ngw Endpoint <code>{{account_naming_prefix}}-&lt;region&gt;-{{endpoint_type}}-&lt;aws_resource&gt;</code> <code>{{endpoint_type}}</code> should describe the endpoint type: <ul><li>ec2</li><li>ecr</li><li>ecs</li><li>s3</li><li>ssm</li></ul> cg-prod-ue1-sharedservices-s3-endpoint  dmpc-network-euw1-ec2-endpoint  genco-dev-ssm-endpoint"},{"location":"AWS/aws-naming-convention/#iam-resources","title":"IAM Resources","text":"AWS Resource Naming Convention Comment Example IAM User Users: <ul><li>{{username}}</li></ul> Service Accounts: <ul><li>{{account_naming_prefix}}-{{service_name}}-<code>&lt;aws_resource&gt;</code></li></ul> Third Party Accounts: <ul><li>{{account_naming_prefix}}-{{client}}-{{identifier}}-<code>&lt;aws_resource&gt;</code></li></ul> Users: <code>{{username}}</code> can vary based upon how you authenticate users within AWS.  You could adopt the first part of email addresses, or import users from third party access management tools, such as Okta or Active Directory  Service Accounts: <code>{{service_name}}</code> should describe the service, for example: <li>terraform</li><li>n2ws-backup</li> Third Party Accounts: <code>{{client}}</code> &amp; <code>{{identifier}}</code> should be used to clearly define the user. For example: <li>Audit</li><li>Support</li><li>S3 Upload</li> User: <li>mscott</li><li>tyrell.wellick</li> Service Account: <li>cg-prod-terraform</li><li>dmpc-network-n2ws-backup</li><li>genco-dev-serviceaccount</li> Third Party Accounts: <li>cg-prod-thirdparty-audit-iam-user</li><li>dmpc-network-thirdparty-support-iam-user</li><li>genco-dev-thirdparty-s3upload-iam-user</li> IAM Role {{account_naming_prefix}}-{{role_purpose}}-<code>&lt;aws_resource&gt;</code>  {{team_naming_prefix}}-{{role_purpose}}-<code>&lt;aws_resource&gt;</code> <code>{{role_purpose}}</code> should explain what the role is for: <li>n2ws-backup</li><li>vpc-flow-logs</li><li>atlantis-deployment</li><li>devops-admin</li><li>ecs-task</li><li>dispatch-lambda</li>  For <code>{{team_naming_prefix}}</code> the <code>&lt;context&gt;</code> can be used to describe a service/project/function Account naming: <ul><li>cg-prod-n2ws-backup-iam-role</li><li>dmpc-network-devops-admin-iam-role</li><li>genco-dev-atlantis-deployment-iam-role</li></ul> Team naming: <ul><li>cg-cis-pe-prod-gitlab-ecs-iam-role</li><li>dmpc-wh-staging-dispatch-lambda-iam-role</li><li>genco-dev-sales-monthlyreport-lambda-iam-role</li></ul> IAM Group {{account_naming_prefix}}-{{group_purpose}} <code>{{group_purpose}}</code> should describe the group: <ul><li>administrators</li><li>management</li><li>billing</li></ul> cg-prod-administrators  dmpc-network-managers  genco-dev-billing IAM Policy {{account_naming_prefix}}-{{policy_purpose}}-<code>&lt;aws_resource&gt;</code>  {{team_naming_prefix}}-{{policy_purpose}}-<code>&lt;aws_resource&gt;</code> <code>{{policy_purpose}}</code> should explain the purpose of the policy:  <ul><li>n2ws-backup</li><li>terraform</li><li>S3 admin</li><li>force-mfa</li><li>billing-view</li></ul> <code>&lt;policy_purpose&gt;</code> can also match the resource being used, or the naming of the role it will be attached to: <ul><li>devops-admin</li><li>dispatch-lambda</li></ul> Account naming: <ul><li>cg-prod-n2ws-backup-iam-policy</li><li>dmpc-network-devops-admin-iam-policy</li><li>genco-dev-atlantis-deployment-iam-policy</li></ul> Team naming: <ul><li>cg-cis-pe-prod-gitlab-ecs-iam-policy</li><li>dmpc-wh-staging-dispatch-lambda-iam-policy</li><li>genco-dev-sales-monthlyreport-lambda-iam-policy</li></ul> KMS {{account_naming_prefix}}-{{kms_type}}-<code>&lt;aws_resource&gt;</code>  {{team_naming_prefix}}-{{kms_type}}-<code>&lt;aws_resource&gt;</code> <code>{{kms_type}}</code> should reference the AWS resource the KMS key is for:  <ul><li>S3</li><li>EBS</li> cg-prod-ue1-sharedservices-s3-kms-key  cg-prod-ue1-sharedservices-s3-kms-policy  dmpc-network-euw1-ebs-kms-key  dmpc-network-euw1-ebs-kms-policy  genco-dev-ecr-kms-key  genco-dev-ecr-kms-policy SSL Certificate {{naming_prefix}}-<code>&lt;resource_identifier&gt;</code>-{{product}}-{{cert_type}}-<code>&lt;aws_resource&gt;</code> <code>{{product}}</code> could describe where the certificate is used:  <li>alb</li><li>elb</li><li>cloudfront</li> <code>{{cert_type}}</code> should describe the certificate:  <li>domain</li><li>wildcard</li> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  It is also possible match the name of the certificate to the domain name e.g.:  <li>portal.capgemini.com</li><li>orders.dmpc.com</li><li>dashboard.genco.info</li>  cg-prod-gitlab-alb-wildcard-cert  dmpc-staging-orders-cloudfront-domain-sslcert  genco-dev-reports-alb-domain-sslcert"},{"location":"AWS/aws-naming-convention/#ec2-resources","title":"EC2 Resources","text":"AWS Resource Naming Convention Comment Example Instances {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>item1</li><li>item2</li><li>item3</li> Account naming: <ul><li>cg-prod-ue1-gitlab-ec2</li><li>dmpc-network-staging-euw2-ip-analysis-ec2</li><li>genco-dev-reports-scripts-ec2</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-gitlab-ec2</li><li>dmpc-wh-staging-euw2-erp-ec2</li><li>genco-dev-sales-reports-ec2</li></ul> Security Groups {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>item1</li><li>item2</li><li>item3</li> Account naming: <ul><li>cg-prod-ue1-gitlab-sg</li><li>dmpc-network-staging-euw2-ip-analysis-sg</li><li>genco-dev-reports-scripts-sg</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-gitlab-sg</li><li>dmpc-wh-staging-euw2-erp-sg</li><li>genco-dev-sales-reports-sg</li></ul> Auto Scaling Groups {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>item1</li><li>item2</li><li>item3</li> Account naming: <ul><li>cg-prod-ue1-gitlab-asg</li><li>dmpc-network-staging-euw2-ip-analysis-asg</li><li>genco-dev-reports-scripts-asg</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-gitlab-asg</li><li>dmpc-wh-staging-euw2-erp-asg</li><li>genco-dev-sales-reports-asg</li></ul> Elastic Load Balancers {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>item1</li><li>item2</li><li>item3</li> Account naming: <ul><li>cg-prod-ue1-gitlab-alb</li><li>dmpc-network-staging-euw2-ip-analysis-nlb</li><li>genco-dev-reports-scripts-lb</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-gitlab-alb</li><li>dmpc-wh-staging-euw2-erp-alb</li><li>genco-dev-sales-reports-lb</li></ul> Launch Configuration {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>item1</li><li>item2</li><li>item3</li> Account naming: <ul><li>cg-prod-ue1-gitlab-lc</li><li>dmpc-network-staging-euw2-ip-analysis-lc</li><li>genco-dev-reports-scripts-lc</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-gitlab-lc</li><li>dmpc-wh-staging-euw2-erp-lc</li><li>genco-dev-sales-reports-lc</li></ul> AMI {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>item1</li><li>item2</li><li>item3</li> Account naming: <ul><li>cg-prod-ue1-base-ami</li><li>dmpc-network-staging-euw2-prometheus-ami</li><li>genco-dev-scripts-ami</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-gitlab-ami</li><li>dmpc-wh-staging-euw2-erp-ami</li><li>genco-dev-sales-stats-dashboard-ami</li></ul> Key Pairs {{account_naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>item1</li><li>item2</li><li>item3</li>  cg-prod-ue1-gitlab-key-pair  dmpc-network-staging-euw2-ec2-keypair  genco-dev-reports-dashboard-kp"},{"location":"AWS/aws-naming-convention/#aws-serverless-resources","title":"AWS Serverless Resources","text":"AWS Resource Naming Convention Comment Example Lambda {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource Account naming: <ul><li>cg-prod-ue1-data-validation-lambda</li><li>dmpc-network-staging-euw2-ip-analysis-lambda</li><li>genco-dev-reports-publish-lambda</li></ul> Team naming: <ul><li>cg-cis-pe-prod-data-transformation-lambda</li><li>dmpc-wh-staging-euw2-orders-dispatch-lambda</li><li>genco-dev-sales-monthlyreport-publish-lambda</li></ul> Step Functions {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> Account naming: <ul><li>cg-prod-ue1-data-ingestion-step-function</li><li>dmpc-network-staging-euw2-ip-analysis-step-function</li><li>genco-dev-reports-step-function</li></ul> Team naming: <ul><li>cg-cis-pe-prod-data-ingestion-step-function</li><li>dmpc-wh-staging-euw2-orders-step-function</li><li>genco-dev-sales-monthlyreport-step-function</li></ul>"},{"location":"AWS/aws-naming-convention/#container-resources","title":"Container Resources","text":"AWS Resource Naming Convention Comment Example ECS Cluster {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>gitlab</li><li>dispatch</li><li>reports</li> Account naming: <ul><li>cg-prod-ue1-gitlab-ecs-cluster</li><li>dmpc-network-staging-euw2-ecs-cluster</li><li>genco-dev-ecs-cluster</li></ul> Team naming: <ul><li>cg-cis-pe-prod-gitlab-ecs-cluster</li><li>dmpc-wh-staging-euw2-dispatch-ecs-cluster</li><li>genco-dev-sales-reports-ecs-cluster</li></ul> ECS Task {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>gitlab-runner</li><li>dispatch</li><li>monthlyreport</li> Account naming: <ul><li>cg-prod-ue1-gitlab-runner-ecs-task</li><li>dmpc-network-staging-euw2-ecs-task</li><li>genco-dev-warehouse-ecs-task</li></ul> Team naming: <ul><li>cg-cis-pe-prod-gitlab-runner-ecs-task</li><li>dmpc-wh-staging-euw2-dispatch-ecs-task</li><li>genco-dev-sales-monthlyreport-ecs-task</li></ul> ECR Repository {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-<code>&lt;aws_resource&gt;</code> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>item1</li><li>item2</li><li>item3</li> Account naming: <ul><li>cg-prod-ue1-ecr</li><li>dmpc-network-staging-ecr</li><li>genco-dev-ecr</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ecr</li><li>dmpc-wh-staging-dispatch-ecr</li><li>genco-dev-sales-ecr</li></ul> EKS Cluster {{naming_prefix}}-<code>&lt;region&gt;</code>-{{cluster_type}}-<code>&lt;aws_resource&gt;</code> <code>{{cluster_type}}</code> should describe cluster:  <ul><li>main</li><li>replica</li></ul> Account naming: <ul><li>cg-prod-ue1-replica-eks-cluster</li><li>dmpc-network-staging-euw2-main-eks-cluster</li><li>genco-dev-main-eks-cluster</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-replica-eks-cluster</li><li>dmpc-wh-staging-euw2-main-eks-cluster</li><li>genco-dev-sales-main-eks-cluster</li></ul> EKS Node {{naming_prefix}}-<code>&lt;region&gt;</code>-{{cluster_type}}-{{node_type}}-<code>&lt;aws_resource&gt;</code> <code>{{cluster_type}}</code> should describe cluster the node belongs to:  <ul><li>main</li><li>replica</li></ul> <code>{{node_type}}</code> should describe the node purpose. This could reference a characteristic or a specific application:  <ul><li>highmem</li><li>highcpu</li><li>gitlab</li><li>prometheus</li> Account naming: <ul><li>cg-prod-ue1-replica-highmem-eks-node</li><li>dmpc-network-staging-euw2-main-highcpu-eks-node</li><li>genco-dev-main-prometheus-eks-node</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-replica-gitlab-eks-node</li><li>dmpc-wh-staging-euw2-main-highcpu-eks-node</li><li>genco-dev-sales-main-prometheus-eks-node</li></ul>"},{"location":"AWS/aws-naming-convention/#s3-resources","title":"S3 Resources","text":"AWS Resource Naming Convention Comment Example S3 Bucket {{naming_prefix}}-<code>&lt;region&gt;</code>-{{bucket_purpose}}-<code>&lt;aws_resource&gt;</code> <code>{{bucket_purpose}}</code> should describe the bucket function:  <li>deployment</li><li>tfstate</li><li>logs</li><li>ingestion</li> cg-prod-ue1-logs-bucket  cg-cis-pe-prod-ue1-deployment-bucket  dmpc-network-staging-euw2-tfstate-bucket  dmpc-wh-staging-euw2-dispatch-bucket  genco-dev-cloudwatch-logs-bucket  genco-sales-dev-monthlyreport-bucket S3 Bucket Policy {{naming_prefix}}-<code>&lt;region&gt;</code>-{{bucket_purpose}}-<code>&lt;aws_resource&gt;</code> <code>{{bucket_purpose}}</code> should describe the bucket function:  <li>deployment</li><li>tfstate</li><li>logs</li><li>ingestion</li> cg-prod-ue1-logs-bucket-policy  cg-cis-pe-prod-ue1-deployment-bucket-policy  dmpc-network-staging-euw2-tfstate-bucket-policy  dmpc-wh-staging-euw2-dispatch-bucket-policy  genco-dev-cloudwatch-logs-bucket-policy  genco-sales-dev-monthlyreport-bucket-policy"},{"location":"AWS/aws-naming-convention/#elasticache-resources","title":"ElastiCache Resources","text":"AWS Resource Naming Convention Comment Example ElastiCache {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-{{engine}}-{{deployment_type}}-<code>&lt;aws_resource&gt;</code> <code>{{engine}}</code> can be one of:  <li>memcached</li><li>redis</li> <code>{{deployment_type}}</code> can be one of:  <li>standalone</li><li>multiaz</li> <code>{{db_resource}}</code> can be one of:  <li>cluster</li><li>instance</li> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>logstash</li><li>metrics</li><li>reports</li> Account naming: <ul><li>cg-prod-ue1-gitlab-redis-standalone-ec</li><li>dmpc-network-staging-euw2-ip-analysis-redis-multiaz-ec</li><li>genco-dev-logstash-memcached-standalone-ec</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-gitlab-redis-multiaz-ec</li><li>dmpc-wh-staging-euw2-dispatch-redis-standalone-ec</li><li>genco-dev-sales-reports-memcached-standalone-ec</li></ul>"},{"location":"AWS/aws-naming-convention/#cloudwatch-resources","title":"CloudWatch Resources","text":"AWS Resource Naming Convention Comment Example CloudWatch Alarm {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-{{alarm_type}}-<code>&lt;aws_resource&gt;</code> <code>{{alarm_type}}</code> should describe the alarm:  <li>scaleup</li><li>scaledown</li><li>cpu-high</li><li>cpu-low</li><li>mem-high</li><li>mem-low</li><li>throughput-high</li><li>throughput-warning</li> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>web-server-efs</li><li>image-server</li><li>gitlab-ec2</li> Account naming: <ul><li>cg-prod-ue1-gitlab-scaleup-alarm</li><li>dmpc-network-staging-euw2-image-server-throughput-warning-alarm</li><li>genco-dev-web-server-cpu-high-alarm</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-gitlab-runner-scaleup-alarm</li><li>dmpc-wh-staging-euw2-image-server-cpu-high-alarm</li><li>genco-dev-sales-reports-throughput-high-alarm</li></ul>"},{"location":"AWS/aws-naming-convention/#rds-resources","title":"RDS Resources","text":"AWS Resource Naming Convention Comment Example RDS Instance {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-{{db_engine}}-{{deployment_type}}-{{db_resource}} <code>{{db_engine}}</code> can be one of:  <li>aurora</li><li>maria</li><li>mysql</li><li>oracle</li><li>postgres</li><li>dynamodb</li> <code>{{deployment_type}}</code> can be one of:  <li>standalone</li><li>multiaz</li><li>writer</li><li>reader</li> <code>{{db_resource}}</code> can be one of:  <li>cluster</li><li>instance</li> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>ip-analysis</li><li>metrics</li><li>reports</li> Account naming: <ul><li>cg-prod-ue1-oracle-standalone-instance</li><li>dmpc-network-staging-euw2-aurora-multiaz-cluster</li><li>genco-dev-aurora-reader-instance</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-ip-analysis-mysql-standalone-instance</li><li>dmpc-wh-staging-euw2-metrics-postgres-standalone-instance</li><li>genco-dev-sales-reports-mysql-cluster</li></ul> Parameter Group {{naming_prefix}}-<code>&lt;region&gt;</code>-<code>&lt;resource_identifier&gt;</code>-{{db_engine}}-{{deployment_type}}-{{db_resource}}-<code>&lt;aws_resource&gt;</code> <code>{{db_engine}}</code> can be one of:  <li>aurora</li><li>maria</li><li>mysql</li><li>oracle</li><li>postgres</li><li>dynamodb</li> <code>{{deployment_type}}</code> can be one of:  <li>standalone</li><li>multiaz</li><li>writer</li><li>reader</li> <code>{{db_resource}}</code> can be one of:  <li>cluster</li><li>instance</li> <code>&lt;resource_identifier&gt;</code> should describe the function of the resource:  <li>ip-analysis</li><li>metrics</li><li>reports</li> Account naming: <ul><li>cg-prod-ue1-oracle-standalone-paramgroup</li><li>dmpc-network-staging-euw2-aurora-multiaz-paramgroup</li><li>genco-dev-aurora-reader-paramgroup</li></ul> Team naming: <ul><li>cg-cis-pe-prod-ue1-ip-analysis-mysql-standalone-paramgroup</li><li>dmpc-wh-staging-euw2-metrics-postgres-standalone-paramgroup</li><li>genco-dev-sales-reports-mysql-paramgroup</li></ul>"},{"location":"AWS/aws-naming-convention/#secrets-resources","title":"Secrets Resources","text":"AWS Resource Naming Convention Comment Example Secrets Manager <code>&lt;environment&gt;</code>/<code>{{secret_type}}</code>/<code>&lt;team&gt;</code>/<code>&lt;resource_identifier&gt;</code>/<code>{{secret_name}}</code> By using a tiered naming approach, you can better control access to secrets using IAM policies. For example, you could deny access within a policy by including <code>prod/app/team/*</code>; alternatively, you could grant access to shared secrets by allowing access to <code>prod/common/*</code> prod/app/cis/pe/gitlab/database  staging/wh/app/dispatch/rds  dev/common/sharedcredential Parameter Store <code>&lt;environment&gt;</code>/<code>{{parameter_type}}</code>/<code>&lt;team&gt;</code>/<code>&lt;resource_identifier&gt;</code>/<code>{{parameter_name}}</code> prod/app/cis/pe/gitlab/user  staging/wh/app/dispatch/user  dev/common/shareduser <p><li>item1</li><li>item2</li><li>item3</li>"},{"location":"AWS/aws-naming-convention/#additional-resources","title":"Additional Resources","text":"<p>Naming conventions</p>"},{"location":"AWS/resource-tagging/","title":"Resource Tagging","text":"<p>The purpose of this document is to outline key concepts of resource tagging and highlight the importance in having a tagging strategy. The ideal tagging strategy will change per organisation, client or project; therefore this document is not intended to be a provide a ready made &amp; reusable strategy, but instead to provide insight and guidance on best practices that will enable you to adopt a strategy that meets individual requirements or challenges.</p> <p>Amazon Web Services (AWS) allows up to 50 tags per AWS resource. Each cloud provider has its own limits, as well as its own defined tagging guidelines. This document may be useful for other cloud providers, but its intended use case is to provide guidance for the AWS platform.</p>"},{"location":"AWS/resource-tagging/#what-are-tags","title":"What are Tags?","text":"<p>Think of tags as labels which can be added to resources such as instances, storage volumes and databases. Metadata in the form of key value pairs, which provide additional information &amp; context about that specific resource. Tags can assist in the identification &amp; management of deployed resources, providing information on who owns a resource, the environment it is used, as well as any other technical or business attributes based on requirements.</p> <p>In order to get the most out of tags, it pays to have a set tagging strategy and to ensure all team members are aware which tags to use and when to use them.  Without a defined strategy, it can become an unsustainable mess. For example, without a standard, you could have over 20 variables of a \"Cost Centre\" tag. </p>"},{"location":"AWS/resource-tagging/#what-are-use-cases-for-tags","title":"What are Use Cases for Tags?","text":"<p>Tags can be used to categorise resources by owner, environment, purpose etc. This can help to understand AWS costs &amp; usage. Tools such as AWS Cost Explorer allow you to use tags to breakdown resource usage.</p> <p>Provides possibilities for security &amp; access control</p> <p>Provides possibilities for automation</p>"},{"location":"AWS/resource-tagging/#aws-best-practices-for-tagging-aws-resources","title":"AWS Best Practices for Tagging AWS Resources","text":"<p>To assist users in developing an optimal tagging strategy, Amazon recommends the following best practices:</p> <ul> <li>Do not add personally identifiable information (PPI) or other confidential or sensitive information in tags. Tags are not intended to be used for private or sensitive data</li> <li>Always use a standardised, case-sensitive format for tags, and implement it consistently across all resource types</li> <li>Consider tag guidelines that support multiple purposes, like managing resource access control, cost tracking, automation and organisation</li> <li>Aim towards too many tags, rather than too few tags. AWS allows for up to 50 tags per resource</li> <li>Implement automated tools to help manage resource tags. The tools should be capable of reallocating existing tags names to comply with a new strategy. AWS Resource Groups and the Resource Groups Tagging API enable programmatic control of tags, making it easier to automatically manage, search and filter tags and resources.</li> <li>Remember that it is easy to modify tags to accommodate changing business requirements, however, consider the ramifications of future changes, especially in relation to tag-based access control, automation or upstream billing reports</li> <li>You can automatically enforce the tagging standards your organisation chooses to adopt by creating and deploying tag policies using AWS Organizations. </li> </ul>"},{"location":"AWS/resource-tagging/#tagging-categories","title":"Tagging Categories","text":"<p>The following categories and tags are not exhaustive. But serve to give an idea on the types of tags which can be used within your tagging strategy:</p> <ul> <li>Technical - Allow engineers to identify and work with resources</li> <li>Automation - Allow automated tasks to be performed against resources</li> <li>Business - Allow stakeholders to identify responsibility and analyse costs </li> <li>Security - Allow security and compliance standards to be adhered, or to provide access to resources</li> </ul> Technical Automation Business Security Name - Identify resources with a unique name  Application ID - Identify resources that belong to a specific application  Application role / service - Describe the function of of a particular resource (web server, bastion, database, message broker)  Cluster - Identify resource groups that share a common configuration &amp; perform a specific function for an application  Environment - Distinguish between development, test &amp; production environments  Version - Distinguish between versions of applications or resources Date/Time - Identify the date or time a resources should be started, stopped, deleted or rotated  Opt in/Opt out - Indicate whether a resource should be included in an automated activity such as starting, stopping or resizing instances  Security - Determine requires such as encryption or enabling of Amazon VPC flow logs; identify resources that need extra security (security groups or route tables) Project - Identify the project that the resources support  Owner - Identify who is responsible for resource  Cost Center/Business Unit - Identify the cost center or business unit associated with a resource, typically for cost allocation  Customer - Identify a client that resources serve Confidentiality - Identify specific data confidentiality levels for a resource  Compliance - Identify if resources need to adhere to specific compliance requirements <p>Note</p> <p>Tags can be added manually to any resource, however it is best practice to define mandatory tags within common templates (AWS CloudFormation) or shared modules (Terraform). This ensures consistency in adhering to the agreed tagging strategy. In addition to this, policies can be set within landing zones to ensure resources are provisioned with required tags</p>"},{"location":"AWS/resource-tagging/#considerations","title":"Considerations","text":"<p>Limits &amp; requirements can be found at the following AWS page</p> <p>The following considerations should be taken into account:</p> <ul> <li>Each resource can have a maximum of 50 user created tags.</li> <li>System created tags that begin with aws: are reserved for AWS use, and do not count against this limit. You can't edit or delete a tag that begins with the aws: prefix.</li> <li>For each resource, each tag key must be unique, and each tag key can have only one value.</li> <li>The tag key must be a minimum of 1 and a maximum of 128 Unicode characters in UTF-8.</li> <li>The tag value must be a minimum of 0 and a maximum of 256 Unicode characters in UTF-8.</li> <li>Allowed characters can vary by AWS service. For information about what characters you can use to tag resources in a particular AWS service, see its documentation. In general, the allowed characters are letters, numbers, spaces representable in UTF-8, and the following characters: <code>_ . : / = + - @</code>.</li> <li>Agree on the naming of tags. Decide how tags will be named and stick to it. For example <code>business_unit</code>, <code>BusinessUnit</code>, <code>businessUnit</code> &amp; <code>business-unit</code> are all valid tag names, however as tags are case sensitive, only one format should be agreed and used across all resources. Avoid using similar tags with inconsistent case treatment.</li> <li>Use tooling to ensure tagging policies are adhered. Or go one step further and use policy as code to ensure resources are not provisioned without mandatory tags. Tools such as AWS Resource Groups can be used to tag instances, and Cloud Custodian can be used to monitor for non-compliant resources.</li> <li>Restrict tag permissions. If you use tags to control resource access, then you may want to restrict who has permissions to update or remove tags</li> <li>Consider the use of prefixes for tags. For example:</li> </ul> <p>There are many tag categories which can be applied to resources; because of this, a truly comprehensive tagging strategy might need input and buy in from several parts of an organisation. This itself brings many challenges, and as such, any agreed tagging strategy will be prone to change. It is important to identify and set a process which allows for any changes to be recorded and visible. It is important to ensure you have a method to keep strategy in place as organisations scale and change.</p>"},{"location":"AWS/resource-tagging/#common-tagging-strategies","title":"Common Tagging Strategies","text":"<p>Using the above mentioned categories, the following strategies can be used to manage AWS resources</p>"},{"location":"AWS/resource-tagging/#tags-for-resource-organisation","title":"Tags for resource organisation","text":"<p>Use tags to organise AWS resources within the AWS Management Console. You can configure tags to be displayed with resources and can search and filter against specific tags. AWS Resource Groups can be used to create groups based on one or more tags. You can also create groups of their occurrence in an AWS CloudFormation stack. With Resource Groups and Tag Editor, you can view data for applications that consist of multiple services, resources &amp; regions in one place</p>"},{"location":"AWS/resource-tagging/#tags-for-cost-allocation","title":"Tags for cost allocation","text":"<p>Using AWS Cost Explorer and detailed billing reports, you can break down AWS costs by tag. You can use business tags such as cost center/business unit, customer or project for traditional cost-allocation dimensions, however any tag can be used for a cost allocation report. This enabled you to associate costs with a technical or security dimension, such as specific applications or environments.</p>"},{"location":"AWS/resource-tagging/#tags-for-automation","title":"Tags for automation","text":"<p>Use tags to filter resources during automation activities. Tags can be used to opt in or out of automated tasks, or to identify resources to archive, update or delete. For example, if you run automated <code>start</code> or <code>stop</code> scripts to turn off instances during non-business hours to reduce costs, you can use tags on EC2 instances to opt out of this task. In this use case you can even be more specific and use tags to set the stop and start times for instances. Scripts can also be used to delete out of date or rolling Amazon EBS snapshots. In this case, tags on snapshots can be used to add an extra dimension of search criteria </p>"},{"location":"AWS/resource-tagging/#tags-for-access-control","title":"Tags for access control","text":"<p>Tags can be used in conjunction with IAM Policies. Tag-based conditions can be used to constrain permissions based on specific tags or tag values. For example, you could restrict an IAM user or an IAM Role permissions so that API calls to a specific environment (such as production) are allow or denied. Again, when you use tags for access control, it is important do define and restrict who has access to modify tags. </p>"},{"location":"AWS/resource-tagging/#mandatory-tags","title":"Mandatory Tags","text":"<p>Define mandatory tags which are to be applied to all resources.</p> Tag Format Example Description application_role/service_name lowercase alphanumerical \"backupdb\" or \"bastion\" Describe the service of the resource in question cost_centre numerical \"384786\" The cost centre for the resources environment lowercase alphanumerical \"prod\" , \"test\", \"dev\", \"uat\" or \"sandbox\" Follow environment naming standards owner lowercase alphanumerical username or team Identify who the owner is for any contact project_id lowercase alphanumerical \"cis-pe-gap\" project id for the resources id numerical \"01\" identifier name programmatic publiccloud-prod-backup-01 Depending on your naming convention, this should ideally be handled by your IaC deployment <p>service_name - Allow for grouping of resources by service, across environments or projects.</p> <p>cost_centre - Breakdown costs by business unit or cost centre. </p> <p>environment - Identify the environment. Can be used in conjunction with conditions within IAM policies to restrict access (to production for example). Can also be used with VPC networks. </p> <p>owner - Assist with service ownership and accountability of resources.</p> <p>project_id - SOmetimes a single cost code can have multiple projects associated. Therefore an additional project ID tag can be used.</p> <p>id - can be used to identify multiple resources of the same name 01 &amp; 02</p> <p>name - The resource name. This should follow a pre-defined naming convention and handles via IaC tooling</p>"},{"location":"AWS/resource-tagging/#tagging-governance","title":"Tagging Governance","text":"<p>For any tagging strategy to be effective, you need to apply it consistently and programmatically across AWS resources. Two approaches to governing tags are reactive and proactive</p> <ul> <li>Reactive - find resources that are not correctly tagged.</li> <li>Proactive - ensure standardised tags are consistently applied at resource creation. </li> </ul> <p> </p> <p>The following tools can be used to assist with tagging governance:</p> <ul> <li>Resource Groups Tagging API</li> <li>AWS Config Rules</li> <li>Custom Scripts</li> <li>Tag Editor - can be used manually with detailed billing reports</li> <li>AWS Service Catalogue - add portfolio and product tags to apply tags to resources automatically when launched</li> <li>AWS Organisations</li> <li>Infrastructure as Code - tools such as AWS CloudFormation or Terraform support resource tagging. Best practice would be to ensure these are used when provisioning resources</li> <li>Cloud Custodian - a third party tool which can be used to enforce tagging strategies using custom policies</li> </ul> <p>A stronger approach can also be adopted, whereby automated tasks are run against non-conformant resources. For example, you can decide to quarantine or terminate resources which are improperly tagged. Tools such as Resource Group Tagging API or Cloud Custodian can be used to achieve this</p>"},{"location":"AWS/resource-tagging/#additional-resources","title":"Additional Resources","text":"<p>AWS - Tagging AWS resources</p> <p>Lucidchart - AWS tagging best practices</p> <p>Harvard - AWS Tagging strategies</p> <p>CloudZero - AWS tagging best practices</p> <p>Cloudforecast - AWS Tags Best Practices and Strategies</p> <p>Terraform vs AWS CloudFormation for AWS Tags</p>"},{"location":"AWS/Cloud-Custodian/policies/","title":"Policies","text":"<p>Report on absent tag values for selected tags <pre><code>policies:\n\n- name: ec2-tag-compliance\nresource: ec2\ncomment: |\nReport on total count of non-compliant instances\nfilters:\n- or:\n- \"tag:SERVICE_NAME\": absent\n- \"tag:TAG_NAME\": absent\n</code></pre></p> <p>Report on non-autoscaling instances without selected tags. Stop after 2 days and terminate after 5 <pre><code>policies:\n\n- name: ec2-tag-compliance-mark\nresource: ec2\ncomment: |\nFind all non-asg instances that are non-conformant to tagging policy. Tag for stoppage in 1 day.\nfilters:\n- \"tag:aws:autoscaling:groupname\": absent\n- \"tag:c7n_status\": absent\n- or:\n- \"tag:SERVICE_NAME\": absent\n- \"tag:TAG_NAME\": absent\nactions:\n- type: mark-for-op\nop: stop\ndays: 1\n\n- name: ec2-tag-compliance-unmark\nresource: ec2\ncomment: |\nAny instances previous marked as non-conformant, that are now compliant should be unmarked.\nfilters:\n- \"tag:c7n_status\": not-null\n- \"tag:SERVICE_NAME\": not-null\n- \"tag:TAG_NAME\": not-null\nactions:\n- unmark\n- start\n\n- name: ec2-tag-compliance-stop\nresource: ec2\ncomment: |\nStop all non-asg instances previously marked for stoppage by today's date, and schedule for termination in 2 days. Verify they are still non-conformant to tagging policies.\nfilters:\n- \"tag:aws:autoscaling:groupname\": absent\n- type: marked-for-op\nop: stop\n- or:\n- \"tag:SERVICE_NAME\": absent\n- \"tag:TAG_NAME\": absent\nactions:\n- stop\n- mark-for-op\nop: terminate\ndays: 3\n\n- name: ec2-tag-compliance-terminate\nresource: ec2\ncomment: |\nTerminate all stopped instances marked for termination.\nfilters:\n- \"tag:aws:autoscaling:groupname\": absent\n- type: marked-for-op\nop: terminate\n- or:\n- \"tag:SERVICE_NAME\": absent\n- \"tag:TAG_NAME\": absent\nactions:\n- type: terminate\nforce: true\n\n- name: ec2-tag-compliance-nag-stop\nresource: ec2\ncomment: |\nStop all instances marked for termination every hour, starting 1 day before their termination.\nfilters:\n- \"tag:aws:autoscaling:groupname\": absent\n- type: marked-for-op\nop: terminate\nskew: 1\n- or:\n- \"tag:SERVICE_NAME\": absent\n- \"tag:TAG_NAME\": absent\nactions:\n- stop\n</code></pre></p>"},{"location":"infrastructure-as-code/terraform/","title":"Terraform best practices","text":"<p>The standards and guide-lines detailed in these pages are a set of working best practices and principles for writing modules that should be followed for all projects. They are based on input from many experienced Terraform users, including those from AWS, HashiCorp, and community grown conventions.</p> <p>Terms mentioned throughout reference the official Terraform Glossary  If you see unfamiliar terms, such as Root module, check the external glossary.</p> <p>HashiCorp (company behind Terraform Project) do not point to specific patterns and best practices in their documentation. There is possibility where you can store whole code in single <code>.tf</code> file, however this is highly discouraged, as navigation in thousands lines of code is usually hard. For small Terraform code and modules, we can observe established pattern, where the code containing resource definitions is put on <code>main.tf</code> file, with  variables and outputs separated into <code>variables.tf</code> and <code>outputs.tf</code> files.</p> <pre><code>.\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 main.tf\n\u251c\u2500\u2500 variables.tf\n\u251c\u2500\u2500 outputs.tf\n</code></pre> <p>As Terraform configuration usually includes <code>terraform{}</code> block (i.e. for adding required providers and for pinning them to particular version), this is often split from <code>main.tf</code> and put into <code>terraform.tf</code> for better readability.</p> <p>Whenever you write Terraform code don't assume it's self explanatory. Different people applies different thinking. Comment your code whenever you feel it might need few words of explanation.</p>"},{"location":"infrastructure-as-code/terraform/#security","title":"Security","text":"<p>Since your Terraform state may contain sensitive data, remember to use encryption at rest whenever you're storing state on S3 bucket or terraform cloud. Whenever your <code>variable</code> or <code>output</code> contains sensitive value, use <code>sensitive = true</code> flag, so it will be masked on terraform log (so also, may be included within logs of CI/CD pipeline).</p>"},{"location":"infrastructure-as-code/terraform/#terragrunt","title":"Terragrunt","text":"<p>Terragrunt is a thin wrapper that provides extra tools for keeping your configurations DRY (Don't Repeat Yourself), working with multiple Terraform modules, and managing remote state. It's also helpful when you work with multiple environments within same project, as you may need different resource names, settings, etc.</p>"},{"location":"infrastructure-as-code/terraform/#aws-resources","title":"AWS Resources","text":"<p>Part of AWS resources that will be required for successful build of infrastructure may require resources, which could be <code>regional</code> or <code>global</code>. While writing IaC in modules, you can distinguish which part of is not region locked (i.e IAM roles, policies, etc), and which is (i.e EC2 instances, S3 buckets, etc).</p>"},{"location":"infrastructure-as-code/terraform/conventions/","title":"Conventions","text":""},{"location":"infrastructure-as-code/terraform/conventions/#naming-conventions","title":"Naming conventions","text":""},{"location":"infrastructure-as-code/terraform/conventions/#general-conventions","title":"General conventions","text":"<p>Note</p> <p>Beware that some cloud resources have restrictions in allowed names. For example, can't contain dashes, some must be camel-cased. The conventions on this page refer to Terraform names themselves.</p> <ol> <li>Resource names should be <code>snake_cased</code>. Use <code>_</code> (underscore) instead of <code>-</code> (dash).</li> <li>Use lowercase letters and numbers</li> </ol>"},{"location":"infrastructure-as-code/terraform/conventions/#resource-and-data-source-arguments","title":"Resource and data source arguments","text":"<ol> <li> <p>Do not repeat resource type in resource name.</p> <p>Good practice</p> <p><code>resource \"aws_route_table\" \"public\" {}</code></p> <p>Bad practice</p> <p><code>resource \"aws_route_table\" \"public_route_table\" {}</code></p> <p>Bad practice</p> <p><code>resource \"aws_route_table\" \"public_aws_route_table\" {}</code></p> </li> <li> <p>Resources should be called <code>this</code> if there is not more descriptive and general name available, or if the resource module creates a single resource of this type.     e.g. in an AWS VPC Module there is a single resource of type <code>aws_nat_gateway</code>, and multiple resources of type <code>aws_route_table</code>. Therefore <code>aws_nat_gateway</code> should be named <code>this</code> and each <code>aws_route_table</code> should have more descriptive names such as <code>private</code>, <code>public</code> or <code>database</code>.</p> </li> <li>Use singular nouns for names.</li> <li>Use <code>-</code> inside argument values and in places where the value will be exposed to a human</li> <li>Any <code>count</code> / <code>for_each</code> arguments inside a resource or data block should be defined as the first argument and separated by a newline after it.</li> <li>Always favour <code>for_each</code> over <code>count</code></li> <li><code>tags</code> should be the last real argument of a resource, followed by <code>depends_on</code> and <code>lifecycle</code>, if necessary. Each of these arguments should be separated by a single empty line.</li> </ol>"},{"location":"infrastructure-as-code/terraform/conventions/#dynamic-resources","title":"Dynamic resources","text":"<p>It is possible to dynamically create resources in Terraform using either count or for_each. Unless count = o or 1, <code>for_each</code> should always be preferred over <code>count</code></p> <p>Since <code>for_each</code> requires a map, you may find a situation where you have a list you want to create resources from dynamically. In this situation, you can convert your list to a set using the <code>toset</code> function. In this case, by passing <code>toset(var.mylist)</code>, Terraform will use each entry as a key.</p> Example <pre><code>resource \"aws_ssm_parameter\" \"params_from_list\" {\n  for_each = toset([\"item1\", \"item2\", \"item3\"])\n\n  name  = each.key\n  type  = \"String\"\n  value = each.value\n}\n\n$ terraform state list\naws_ssm_parameter.params_from_list[\"item1\"]\naws_ssm_parameter.params_from_list[\"item2\"]\naws_ssm_parameter.params_from_list[\"item3\"]\n\n$ terraform state show aws_ssm_parameter.params_from_list[\"item1\"]\n{ ...\nname  = \"item1\"\nvalue = \"item1\"\n... }\n</code></pre>"},{"location":"infrastructure-as-code/terraform/conventions/#default-tags","title":"Default tags","text":"<p>You should ensure that all resources that can accept tags, have tags defined.</p> <p>For the Terraform <code>aws</code> provider, it is possible to use <code>default_tags</code>. This feature should not be used inside the modules block, but instead inside the root module. Doing so will add default tags to all supported resources being deployed</p>"},{"location":"infrastructure-as-code/terraform/conventions/#attachment-over-embedded-resources","title":"Attachment over embedded resources","text":"<p>Some resources allow pseudo resources embedded as attributes in them. Where possible, it is best practice to avoid using these. Instead you should opt to create the resource type and then attach the psuedo-resource. This will reduce chicken/egg issues that are unique per resource. </p> <p>Avoid</p> <pre><code>resource \"aws_security_group\" \"allow_tls\" {\n  ...\n  ingress {\n    description      = \"TLS from VPC\"\n    from_port        = 443\n    to_port          = 443\n    protocol         = \"tcp\"\n    cidr_blocks      = [aws_vpc.main.cidr_block]\n    ipv6_cidr_blocks = [aws_vpc.main.ipv6_cidr_block]\n  }\n\n  egress {\n    from_port        = 0\n    to_port          = 0\n    protocol         = \"-1\"\n    cidr_blocks      = [\"0.0.0.0/0\"]\n    ipv6_cidr_blocks = [\"::/0\"]\n  }\n}\n</code></pre> <p>Preferred</p> <pre><code>resource \"aws_security_group\" \"allow_tls\" {\n  ...\n}\n\nresource \"aws_security_group_rule\" \"example\" {\n  type              = \"ingress\"\n  description      = \"TLS from VPC\"\n  from_port        = 443\n  to_port          = 443\n  protocol         = \"tcp\"\n  cidr_blocks      = [aws_vpc.main.cidr_block]\n  ipv6_cidr_blocks = [aws_vpc.main.ipv6_cidr_block]\n  security_group_id = aws_security_group.allow_tls.id\n}\n</code></pre>"},{"location":"infrastructure-as-code/terraform/documentation/","title":"Documentation","text":"<p>All modules or deployments of Terraform should contain documentation that explains the purpose or describes usage of resources. This is usually in the form of a <code>README</code> within each directory/repository.</p>"},{"location":"infrastructure-as-code/terraform/documentation/#terraform-docs","title":"Terraform-docs","text":"<p>Terraform-docs is a utility which can be used to automate the generation of documentation files for each terraform deployment. The website contains a guide on how to install, as well as how to use the utility via CLI, GitHub actions or via pre-commit hook.</p>"},{"location":"infrastructure-as-code/terraform/installation/","title":"Installation","text":"<p>Terraform can be installed a variety of different ways for multiple operating systems. </p> <p>Consult the Terraform website for installation steps</p>"},{"location":"infrastructure-as-code/terraform/installation/#tf-switch","title":"TF Switch","text":"<p>TF switch is a command line tool that allows you to switch between different versions of Terraform (useful when testing upgrades)</p> <p>Info</p> <p><code>tfswitch</code> is only available for Linux and MacOS systems If using Windows, this can be installed within WSL/WSL2</p>"},{"location":"infrastructure-as-code/terraform/installation/#installation_1","title":"Installation","text":"<p>The installation steps for <code>tfswitch</code> can be found here</p> <p>Tip</p> <p>When installing in WSL2, you may encounter an error which can be resolved using the solution provided here. However when running this fix, you are told to add <code>$HOME/.bin</code> to your PATH, but <code>tfswitch</code> installs <code>terraform</code> to <code>$HOME/bin</code> by default. This can be fixed by editing the path export to add <code>$HOME/bin</code> to PATH instead</p>"},{"location":"infrastructure-as-code/terraform/modules/","title":"Modules","text":""},{"location":"infrastructure-as-code/terraform/modules/#why-use-modules","title":"Why use modules?","text":"<p>A Terraform module allows you to create logical abstraction on the top of a resource set. In other words, modules allows you to group resources together and reuse multiple times without the need to duplicate code.</p> <p>For example, we have a requirement to create a virtual server in the cloud. We may need the following resources:  - the virtual machine, created from an image  - attached block device, with a specified size for additional storage  - a static IP address mapped to the servers virtual network interface  - a set firewall rules attached to the server</p> <p>By creating a module for your virtual machine, it will allow you to create this server multiple times - all without having to repeat the same configuration code over and over.</p> <p>Below is an example of how to call the virtual machine module  \"To call a module\" means to use it in the configuration file.</p> <p>Example</p> <pre><code>module \"server\" {\n\ncount         = 5\n\nsource        = \"./module_server\"\nsome_variable = some_value\n}\n</code></pre> <p>Info</p> <p>Terraform supports \"count\" for modules starting from version 0.13</p>"},{"location":"infrastructure-as-code/terraform/modules/#organising-modules","title":"Organising modules","text":"<p>It's best practice to create a module for any distinct logical component of infrastructure. This could be:</p> <ul> <li>a network like a virtual private cloud/virtual network</li> <li>static content hosting (i.e. buckets)</li> <li>virtual machines</li> <li>databases</li> <li>load balancers</li> <li>logging configuration</li> </ul>"},{"location":"infrastructure-as-code/terraform/modules/#module-sources","title":"Module sources","text":"<p>Once you have several custom modules, these can be referred to as \"child\" modules. The configuration where you call the child modules is the \"root\" module The child module can be sourced from a number of places:</p> <ul> <li>local paths</li> <li>the official Terraform Registry</li> <li>a Git repository</li> <li>an HTTP URL to a <code>.zip</code> archive containing the module</li> </ul>"},{"location":"infrastructure-as-code/terraform/modules/#structure","title":"Structure","text":"<p>Modules should look to maintain a structure that contains at least the below files:</p> <pre><code>\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 main.tf\n\u251c\u2500\u2500 variables.tf\n\u251c\u2500\u2500 outputs.tf\n</code></pre> <ul> <li><code>main.tf</code> - contains Terraform resources</li> <li><code>outputs.tf</code> - contains Module outputs</li> <li><code>provider.tf</code> - contains the terraform block with <code>required_providers</code></li> <li><code>variables.tf</code> - contains variable declarations</li> </ul> <p>Other files:</p> <ul> <li><code>data.tf</code> - includes <code>locals</code> &amp; <code>data</code> declarations. Note: it is common for these declarations to be included in the <code>main.tf</code> file instead</li> <li><code>alias.tf</code>- can be used if you have aliased providers to declare</li> <li> <p><code>versions.tf</code> - alternative name for <code>provider.tf</code>. </p> <p>Info</p> <p>This convention comes from the <code>terraform0.12-upgrade</code> command where once terraform code was upgraded from v0.11.x to v0.12.x a <code>versions.tf</code> file was create to enforce <code>terraform { required_version = \"&gt;= 0.12.0}\"</code></p> </li> </ul> <p>Service named files: It's common to create several files and separate terraform resources by service. This should be stifled as much as possible in favour of defining resources inside the <code>main.tf</code>. If a collection of resources, for example IAM Roles and Policies, exceed 150 lines then it is reasonable to break that into its own files such as <code>iam.tf</code>. Otherwise all resource code should be defined in the <code>main.tf</code>.</p> <p>Note</p> <p>As best practice, you should look to maintain module code in addition to examples &amp; functional tests.</p>"},{"location":"infrastructure-as-code/terraform/modules/#examples-testing","title":"Examples &amp; Testing","text":"<p>Its good practice to include at least one working deployment example, and multiple examples to cover various usage patterns. By convention, it is best practice to call this test <code>basic</code> </p> <p>Modules should provide tests to guarantee provided functionality. These tests can be done via Terratest. These tests should verify each deployment example in addition to any other functionality. Example specific tests should be named <code>examples_&lt;example_name&gt;_test.go</code>. Tests that are generic to the module should be named <code>&lt;module_name&gt;_tests.go</code></p> <pre><code>$ tree\n\u251c\u2500\u2500 examples\n\u2502   \u251c\u2500\u2500 basic\n\u2502   \u2502   \u251c\u2500\u2500 main.tf\n\u2502   \u2502   \u251c\u2500\u2500 outputs.tf\n\u2502   \u2502   \u2514\u2500\u2500 variables.tf\n\u2502   \u2514\u2500\u2500 formatted_tags\n\u2502       \u251c\u2500\u2500 main.tf\n\u2502       \u2514\u2500\u2500 variables.tf\n\u251c\u2500\u2500 modules\n\u2502   \u2514\u2500\u2500 my_sub_module/\n\u251c\u2500\u2500 test\n\u2502   \u251c\u2500\u2500 examples_basic_test.go\n\u2502   \u251c\u2500\u2500 examples_formatted_tags_test.go\n\u2502   \u2514\u2500\u2500 label_test.go\n\u251c\u2500\u2500 LICENSE\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 main.tf\n\u251c\u2500\u2500 variables.tf\n\u251c\u2500\u2500 outputs.tf\n</code></pre>"},{"location":"infrastructure-as-code/terraform/variables-and-outputs/","title":"Variables &amp; Outputs","text":""},{"location":"infrastructure-as-code/terraform/variables-and-outputs/#variables","title":"Variables","text":"<ol> <li> <p>All input variables must contain <code>type</code> and <code>description</code> arguments</p> </li> <li> <p>To ensure a variable is required, omit the <code>default</code> argument from the declaration.      &gt;Note: It may also be worth considering the disallowing of <code>null</code> make sense.</p> </li> <li> <p>Order arguments in a variable block like this: <code>description</code> , <code>type</code>, <code>default</code>, <code>validation</code>.</p> </li> <li> <p>Prefer using simple types (number, string, <code>list(...)</code>, <code>map(...)</code>, <code>any</code>) over specific type like <code>object()</code> unless you need to have strict constraints on each key.</p> </li> <li> <p>Use specific types like <code>map(map(string))</code> if all elements of the map have the same type (e.g. <code>string</code>) or can be converted to it (e.g. <code>number</code> type can be converted to <code>string</code>)</p> </li> <li> <p>Use the plural form in a variable name when type is <code>list(...)</code> or <code>map(...)</code>.</p> </li> <li> <p>Where input is subjective, or where specific behaviour needs to be prevented, variable validation should be used.      &gt; Note: more variable validation examples can be found here</p> </li> </ol>"},{"location":"infrastructure-as-code/terraform/variables-and-outputs/#outputs","title":"Outputs","text":"<ol> <li> <p>All output values should consistent and understandable outside its scope. It should be obvious what type and attribute is returned.</p> </li> <li> <p>The name of the output should describe the property it contains.</p> </li> <li> <p>Use the plural form in a output name when type is <code>list(...)</code>.</p> </li> <li> <p>A good structure for the output name is <code>&lt;name&gt;_&lt;type&gt;_&lt;attribute&gt;</code>, where:</p> </li> <li><code>&lt;name&gt;</code> is the resource or data source name without the provider prefix<ul> <li><code>aws_subnet</code> is <code>subnet</code> or <code>aws_vpc</code> is <code>vpc</code></li> </ul> </li> <li><code>&lt;type&gt;</code> is a type of resource sources</li> <li> <p><code>&lt;attribute&gt;</code> is the attribute return by the output</p> </li> <li> <p>Always include a <code>description</code> for all outputs, even if you think its obvious.</p> </li> <li> <p>Prefer try() (available since Terraform 0.13) over element(concat(...)) (legacy approach for the version before 0.13)</p> </li> </ol>"},{"location":"misc/readme-best-practice/","title":"Readme best practice","text":""},{"location":"misc/readme-best-practice/#readme-creation-best-practices","title":"README creation best practices.","text":""}]}